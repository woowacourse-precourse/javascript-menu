1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다. => 요구사항
2. 시스템 책임을 더 작은 책임으로 분할
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당.
4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체, 또는 역할 찾기
5. 해당 객체, 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
6. 이 코드가 현실 문제, 즉 비즈니스에 대한 의사결정을 하고 있는가?
7. 행동 -> 데이터 -> 구현

# 기능

## 기능요구사항

- 한 주에 같은 카테고리는 최대 2회까지만 고를 수 있다.
- 각 코치에게 한 주에 중복되지 않는 메뉴를 추천해야 한다.

1. - [x] 사용자로부터 ','로 구분하여 코치의 이름을 입력받는다.
2. - [x] 코치의 수 만큼, 각 코치가 못먹는 메뉴를 ','로 구분하여 입력받는다.
3. - [x] 만약 월요일의 메뉴를 추천한다고 치면, 추천할 카테고리를 무작위로 하나 선정한다.
4. - [x] 위에서 나온 카테고리가 만약 이미 2회 나왔던 거라면, 다시 돌아가 카테고리를 무작위로 하나 선정한다.
5. - [x] 각 코치가 먹지 못하는 메뉴를 고려하고, 이미 지난번에 그 코치가 먹었던 음식인지를 고려하여 위에서 나온 카테고리의 메뉴를 코치의 수만큼 선정한다.
6. - [ ] 위의 과정을 월,화,수,목,금 반복하며 기록한다.
7. - [ ] 메뉴추천결과를 출력한다.

## 예외처리

- 요구사항 읽으면서 적어라

1. - [ ] 코치의 이름이 '2글자~4글자' 사이의 글자가 아니라면 예외처리한다.
2. - [ ] 코치가 2명보다 적거나 5명보다 많으면 예외처리한다.
3. - [ ] 사용자가 못먹는다고 고른 음식이 가능한 메뉴에 없는 음식이라면 예외처리한다.(?)

# 설계

1. 필요할 것 같은 역할,타입,객체:
   인풋, 아웃풋, 메뉴매니저 = 매뉴컨트롤러, 메뉴추천(도메인로직), 코치, 메뉴판, 랜덤숫자생성기, 카테고리 기록기, 메뉴추천기록기

2. 역할, 타입, 객체의 책임(요구사항을 보며 작성할 것):

- 메뉴추천기능을 진행하라-> [메뉴매니저]
  - 코치의 이름을 입력받아라-> [메뉴컨트롤러] : 코치의 이름
    - 코치의 이름을 입력받아라(콜백)-> [인풋] : 코치의 이름
  - 이 코치들을 등록하라(코치의 이름)-> [메뉴추천]
    - 이러한 정보의 코치를 생성하라-> [코치]
  - 코치가 못먹는 음식을 입력받아라 -> [메뉴컨트롤러] : 코치가 못먹는 음식
    - 코치가 못먹는 음식을 입력받아라(콜백) -> [인풋] : 코치가 못먹는 음식
  - 코치가 못먹는 이 음식을 알고있어라(코치가 못 먹는 음식)-> [메뉴추천]
    - 각 코치에게 못 먹는 음식에 대한 정보를 등록하라(못 먹는 음식)-> [코치]
  - 메뉴를 추천하라-> [메뉴추천] : 날마다의 메뉴추천리스트
    - 무작위로 하나의 카테고리를 선정하라-> [메뉴판] : 카테고리
    - 이미 2회이상 나왔던 카테고리인지 확인하라(카테고리)-> [카테고리기록기] : 여부
    - 아니라면, 해당 카테고리를 기록기에다가 써라(카테고리)-> [카테고리기록기]
    - 위 카테고리에서, 각 코치가 먹을 음식을 선정하라(카테고리)-> [메뉴판] : 음식
    - 니가 먹을 수 있는 음식인지 판별하라(음식) -> [코치]
    - 이미 이전에 먹었던 음식인지 판별하라(음식) -> [코치]
    - 위 두 제한 사항을 넘어갔다면 음식을 먹었다고 기록하라(음식) -> [코치]
    - 니들이 먹은 음식을 너희들의 이름과 요일과 함께 내놔라 -> [코치] : 먹은음식 정보
    - 위에서 받은 정보를 써라(코치들이 날마다 먹었던 음식의 정보)-> [메뉴추천기록기]

# 주의사항

- 요구사항 읽으면서 구현하다가 이거 놓치겠다 싶은 것은 다 적어놔라

1. 인덴트 2
2. 메서드 15라인

- 메뉴 추천 서비스에서 추천할 수 있는 카테고리와 각 카테고리의 메뉴는 아래와 같다.
  일식: 규동, 우동, 미소시루, 스시, 가츠동, 오니기리, 하이라이스, 라멘, 오코노미야끼
  한식: 김밥, 김치찌개, 쌈밥, 된장찌개, 비빔밥, 칼국수, 불고기, 떡볶이, 제육볶음
  중식: 깐풍기, 볶음면, 동파육, 짜장면, 짬뽕, 마파두부, 탕수육, 토마토 달걀볶음, 고추잡채
  아시안: 팟타이, 카오 팟, 나시고렝, 파인애플 볶음밥, 쌀국수, 똠얌꿍, 반미, 월남쌈, 분짜
  양식: 라자냐, 그라탱, 뇨끼, 끼슈, 프렌치 토스트, 바게트, 스파게티, 피자, 파니니

- 추천할 카테고리는 [MissionUtils 라이브러리](https://github.com/woowacourse-projects/javascript-mission-utils#mission-utils)의 `Random.pickNumberInRange()`에서 생성해 준 값을 이용하여 정해야 한다.

- 임의로 카테고리의 순서 또는 데이터를 변경하면 안 된다.
  - `Randoms.pickNumberInRange()`의 결과가 **1이면 일식, 2면 한식, 3이면 중식, 4면 아시안, 5면 양식**을 추천해야 한다.
- 추천할 수 없는 카테고리인 경우 다시 `Randoms.pickNumberInRange()`를 통해 임의의 값을 생성해서 추천할 카테고리를 정해야 한다.

추천할 메뉴는 정해진 카테고리에 있는 메뉴를 [MissionUtils 라이브러리](https://github.com/woowacourse-projects/javascript-mission-utils#mission-utils)의 `Random.shuffle()`을 통해 임의의 순서로 섞은 후, 첫 번째 값을 사용해야 한다.

- 카테고리에 포함되는 메뉴 목록은 `문자열 배열` 형태로 담아 준비한다.

- 임의로 메뉴의 순서 또는 데이터를 변경하면 안 된다.
- `Randoms.shuffle()` 메서드의 인자로 전달되는 메뉴 데이터는, 최초에 제공한 목록을 그대로 전달해야 한다.
  - 코치에게 추천할 메뉴를 정할 때 이미 추천한 메뉴, 먹지 못하는 메뉴도 포함된 리스트를 전달해야 한다.
- 추천할 수 없는 메뉴인 경우 다시 섞은 후 첫 번째 값을 사용해야 한다.

# 팁

1. 설계할 때, 인자와 리턴하는 것까지 고려해야한다.
2. 설계할 때, 만약 반복적으로 무언가를 해야한다면, 이 반복작업이 언제끝나는지까지, 어떻게 끝나야하는지까지 고려해야한다.
3. 설계할 때, 어떤 조건사항에 대한 구현사항을 안헷갈리게 작성해라. ~할 때, 라고 명확히 분류할 것.
4. 설계할 때, 어떻게 구현하면 되겠다라는 그림을 명확히 잡고 가야됨. 그런게 떠오르지 않는다면 그것은 잘못된 설계다.
5. 설계하고나서 구현할 때, 이 메시지로 인한 이 메소드가 과연 필요할까 의심하지 말고 일단 구현할 것.
6. 설계하고나서 구현할 때, 일단 "만약 ~한다면"이라는 메시지는 onFinish같이 이런 종류의 메서드로 구현하면 좋다고 생각할 것.
7. 구현할 때, 뭘 구현해야하는지 큰 그림은 요구사항을 보되, 자잘하게 구현하는 법은 설계를 볼 것. 어느 협력자로 인해 리턴 받은 값을 어떻게 활용하는지 주의깊게 봐야한다.
8. 요구사항 문서 읽으면서 예외 발견
9. 구현하면서 어느정도 함수 나누는 리팩토링은 해둘 것.
10. 구현하면서 테스트 -> 기능요구사항에서 작성한 것들 하나하나 구현하고, 테스트가 바로 가능할 것 같은 메소드들은 바로 테스트해버릴 것
11. 요구사항 분석 - 설계는 최소 1시간 안에
12. 예외발생은 가능하면 안으로 집어넣을 것인데 13번이 가능하면 안해도 될듯?
13. 인풋 받는 기능 -> 각 인풋 단위로 메서드 분리. 인풋 처리 부분은 다른 메서드로 분리. 그렇게 해서 예외처리할 것.
14. 설계할 때, 이미 파일 속에 만들어진것들이 있다면 그것들을 참고할 것. 특히, 객체들의 유의사항을 읽어보며 무엇을 위한 객체인지 의도를 파악하기.
15. 주의사항 제발 잘 읽어볼 것. 어느 클래스엔 뭐가 있으면 안된다.
16. 모델은 도메인로직을 위한 것. 도메인(비즈니스)로직이 뭔지는 메모장을 봐라.
17. 컨트롤러는 뷰, 도메인로직의 매개자
18. 구현할 때, 알고리즘 공부했던 것 처럼, 논리적으로 서술하라. 어떻게하면 되겠다는..한단계한단계씩. 그러면 분명 애매하거나 잘 모르겠거나 하는 부분있는데, 그걸 그냥 넘어가면 안된다. 그걸 어떻게 하면 되겠다고 명확한 생각이 있어야 문제가 풀린다.
19. 기능요구사항은 요구사항을 읽어보고 실행결과예시를 보면서 작성하면 편하다.
20. 기능요구사항을 작성하다가 어떤 조건의 경우에 따라 다르게 처리해야할 상황이 온다면, 우선 제일 먼저 프로그램을 빠져나가는 조건부터 처리한다.
21. 어떻게 반복시킬까? 어떻게 정상적으로 종료될까? 는 나중에 생각해도 된다.
